import os, sys
sys.path.append(os.getcwd())

import time
import argparse

import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
import numpy as np
import tensorflow as tf
tf.compat.v1.random.set_random_seed(1234)

import tflib as lib
import tflib.ops.linear
import tflib.ops.conv2d
import tflib.ops.batchnorm
import tflib.ops.deconv2d
import tflib.save_images
import tflib.nist
import tflib.plot
from tflib.utils import load_model_from_checkpoint
from gan_nist import Discriminator, Generator

lib.print_model_settings(locals().copy())

def generate_image(noise_samples):
    samples = sess.run(noise_samples)
    lib.save_images.save_images(
        samples.reshape((128, INPUT_WIDTH, INPUT_HEIGHT)), 
        os.path.join(OUTPUT_IMAGES_PATH,'samples_{}_nist.png'.format(MODE))
    )

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Train WGAN with nist dataset after preprocessing')
    parser.add_argument('--dim', type=int, default=64, help='Model dimensionality')
    parser.add_argument('--mode', choices=['wgan-gp', 'wgan', 'dcgan'], help='Architecture and type of the generative model', default='wgan-gp')
    parser.add_argument('--path_generated_images', type=str, help='Optional path to save the images generated by the model in the training', default='')
    parser.add_argument('--model_path', help='Path for load model weights', default='models/wgan-gp')

    args = parser.parse_args()

    INPUT_HEIGHT = 28
    INPUT_WIDTH = 28
    OUTPUT_DIM = INPUT_HEIGHT*INPUT_WIDTH  # Number of pixels in NIST

    MODE = args.mode
    DIM = args.dim
    OUTPUT_IMAGES_PATH = args.path_generated_images
    MODEL_PATH = args.model_path

    tf.reset_default_graph()

    # Create the variables for Generator and Discriminator
    
    _ = Generator(1, DIM, INPUT_HEIGHT*INPUT_WIDTH, MODE)
    _ = Discriminator(tf.placeholder(tf.float32, shape=[1, OUTPUT_DIM]), INPUT_WIDTH, INPUT_HEIGHT, DIM, MODE)
    
    # Add ops to save and restore all the variables.
    saver = tf.train.Saver()

    with tf.Session() as sess:
        # Restore variables from disk.
        _ = load_model_from_checkpoint(os.path.join(MODEL_PATH, ''), saver, sess)
        
        fixed_noise = tf.constant(np.random.normal(size=(128, 128)).astype('float32'))
        fixed_noise_samples = Generator(128, noise=fixed_noise)
        generate_image(fixed_noise_samples)
        